//Nest

const geometry = new THREE.Geometry();

for (let i = 0; i < 5000; i++) {
  for (let j = 0; j < 3; j++) {
    geometry.vertices.push(
      new THREE.Vector3(
        (Math.random() - 0.5) * 4,
        (Math.random() - 0.5) * 4,
        (Math.random() - 0.5) * 4
      )
    );
  }

  const verticesIndex = i * 3;
  geometry.faces.push(
    new THREE.Face3(verticesIndex, verticesIndex + 1, verticesIndex + 2)
  );
}

const material = new THREE.MeshBasicMaterial({
  color: param.color,
  wireframe: true,
});
const mesh = new THREE.Mesh(geometry, material);
mesh.visible = false;
mesh.position.y = 1;
scene.add(mesh);

/*Dat.Gui */

const gui = new dat.GUI({ closed: true });

const param = {
  color: 0x73db40,
  spin: () => {
    gsap.to(mesh.rotation, { duration: 1, y: mesh.rotation.y + 10 });
  },
};

gui.addColor(param, "color").onChange(() => {
  material.color.set(param.color);
});

gui.add(param, "spin");

/*
const geometry1 = new THREE.BoxGeometry(1, 1, 1)
const material1 = new THREE.MeshBasicMaterial({ color: 0xff0000 })
const mesh2 = new THREE.Mesh(geometry1, material1)
mesh2.position.y=0.5
scene.add(mesh2)
*/

function animate() {
  // Újabb képkocka rajzolásának kérése.
  // Maximálisan 60 FPS-t biztosít a rendszer.
  requestAnimationFrame(animate);
  // Kameramozgás vezérlése
  controls.update();
  // Új képkocka rajzolása

  // vizcsova mozgatasa

  vizcsova.rotation.y += 0.03;
  vizcsova.rotation.x += 0.01;

  if (vizcsova.position.y >= 3) {
    felle = 1;
  } else if (vizcsova.position.y <= 1.5) {
    felle = 0;
  }

  if (felle == 0) {
    vizcsova.position.y += 0.01;
  } else {
    vizcsova.position.y -= 0.01;
  }

  // vonat mozgatasa

  if (vonat.position.x >= 30) {
    odavissza = 1;
    vonat.rotation.y -= Math.PI;
  } else if (vonat.position.x <= 0) {
    vonat.rotation.y -= Math.PI;

    odavissza = 0;
  }

  if (odavissza == 0) {
    vonat.position.x += 0.08;
  } else {
    vonat.position.x -= 0.08;
  }

  //tween animalas
  TWEEN.update();

  render();
}

if (startX == endX) {
  roadType = globals.groundObject.road.road_hori;
} else if (startZ == endZ) {
  roadType = globals.groundObject.road.road_verti;
} else if (startX > endX && startZ > endZ) {
  roadType = globals.groundObject.road.road_down_left;
} else if (startX < endX && startZ > endZ) {
  roadType = globals.groundObject.road.road_down_right;
} else if (startX > endX && startZ < endZ) {
  roadType = globals.groundObject.road.road_up_left;
} else if (startX < endX && startZ < endZ) {
  roadType = globals.groundObject.road.road_up_right;
}
if (startX > endX) {
  while (startX != endX) {
    if (!globals.map.has(`${startX}_${startZ}`)) {
      if (startX == endX + 1) {
        globals.map.set(`${startX}_${startZ}`, roadType);
      } else {
        globals.map.set(
          `${startX}_${startZ}`,
          globals.groundObject.road.road_hori
        );
      }
    }
    startX--;
  }
} else {
  while (startX != endX) {
    if (!globals.map.has(`${startX}_${startZ}`)) {
      if (startX == endX - 1) {
        globals.map.set(`${startX}_${startZ}`, roadType);
      } else {
        globals.map.set(
          `${startX}_${startZ}`,
          globals.groundObject.road.road_hori
        );
      }
    }
    startX++;
  }
}

if (startZ > endZ) {
  while (startZ != endZ) {
    if (!globals.map.has(`${startX}_${startZ}`)) {
      if (startX == endX + 1) {
        globals.map.set(`${startX}_${startZ}`, roadType);
      } else {
        globals.map.set(`${startX}_${startZ}`, globals.groundObject.road.verti);
      }
    }
    startZ--;
  }
} else {
  while (startZ != endZ) {
    if (!globals.map.has(`${startX}_${startZ}`)) {
      if (startX == endX - 1) {
        globals.map.set(`${startX}_${startZ}`, roadType);
      } else {
        globals.map.set(`${startX}_${startZ}`, globals.groundObject.road.verti);
      }
    }
    startZ++;
  }
}
